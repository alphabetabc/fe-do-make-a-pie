const colors=[[0,235,15,15],[.1,235,15,15],[.16,255,246,0],[.4,15,235,103],[.54,15,235,103],[.67,255,246,0],[.78,235,15,15],[.9,0,99,177],[1,235,15,15]],gradientColors=[];colors.forEach((t,e)=>{if(e===colors.length-1)return;let s=0;const o=t.map((r,i)=>{const a=r-colors[e+1][i],n=Math.abs(a);return Math.abs(s)<n&&(s=n),a});gradientColors.push([t[0],`rgb(${t.slice(1).join(",")})`]);let l=t[0];const c=(colors[e+1][0]-l)/s;for(let r=0;r<s-1;r++){let i="rgb($0,$1,$2)";for(let a=1;a<t.length;a++){let n=t[a];n=n-o[a]/s,t[a]=n,i=i.replace(`$${a-1}`,n)}l=l+c,gradientColors.push([l,i])}});const lastColor=colors[colors.length-1];gradientColors.push([lastColor[0],`rgb(${lastColor.slice(1).join(",")})`]);const testData={startAngle:225,endAngle:-45,splitNumber:6,max:65,data:[30]},axisLabelData=[0,40,45,50,55,60,65],axisLabelOriginData=(()=>{const t=[];for(let e=0;e<testData.splitNumber+1;e++)t.push(+(testData.max/testData.splitNumber*e).toFixed(10));return t})();function parseValue(t,[e,s],[o,l]){return t===0?0:(l-o)/(s-e)*(t-e)+o}let value=testData.data[0],valueIndex=-1;axisLabelData.some((t,e)=>(valueIndex=e,value<=t));const k=[axisLabelData[valueIndex-1],axisLabelData[valueIndex]],z=[axisLabelOriginData[valueIndex-1],axisLabelOriginData[valueIndex]];value=parseValue(value,k,z);const baseOut={type:"gauge",axisLabel:{show:!1},axisLine:{show:!1,lineStyle:{color:gradientColors}},axisTick:{length:4,lineStyle:{color:"auto",width:2},splitNumber:150},splitLine:{show:!1,lineStyle:{color:"auto"}},detail:{show:!1}},baseInner={radius:"70%",type:"gauge",axisLine:{show:!1,lineStyle:{color:gradientColors}},splitLine:{length:12,lineStyle:{color:"auto"}},axisTick:{lineStyle:{width:2,color:"auto"},splitNumber:10},pointer:{width:5,length:"70%"},axisLabel:{formatter(t){const e=axisLabelOriginData.findIndex(s=>s===t);return axisLabelData[e]}}};option={series:[baseOut,{...baseInner,...testData,data:[value],detail:{formatter:String(testData.data[0])}}]};
